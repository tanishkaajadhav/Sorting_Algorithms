(a) SELECTION SORT – SELECTIONSORT.CPP

AIM:

To sort a given array in ascending order using the selection sort algorithm.

APPARATUS:

Laptop with C++ compiler (MinGW), Text Editor / IDE (VS Code), Terminal/Console (Command Prompt).

THEORY:

Selection sort repeatedly selects the minimum element from the unsorted part of the array and swaps it with the first element of the unsorted part. It works efficiently for small arrays but has O(n²) time complexity.

ALGORITHM:

Start the program and include necessary header files.

Input the number of elements and the array elements.

For each element in the array, find the minimum element in the unsorted part.

Swap the minimum element with the first element of the unsorted part.

Repeat until the array is sorted.

Display the sorted array.

Stop the program.

CONCLUSION:

The program successfully sorts an array using selection sort.

(b) BUBBLE SORT – BUBBLESORT.CPP

AIM:

To sort a given array in ascending order using the bubble sort algorithm.

APPARATUS:

Laptop with C++ compiler (MinGW), Text Editor / IDE (VS Code), Terminal/Console (Command Prompt).

THEORY:

Bubble sort repeatedly compares adjacent elements and swaps them if they are in the wrong order. Larger elements “bubble” to the end of the array in each pass. It has O(n²) time complexity.

ALGORITHM:

Start the program and include necessary header files.

Input the number of elements and the array elements.

Use nested loops to compare and swap adjacent elements.

Repeat until the array is completely sorted.

Display the sorted array.

Stop the program.

CONCLUSION:

The program successfully sorts an array using bubble sort.

(c) QUICK SORT – QUICKSORT.CPP

AIM:

To sort a given array in ascending order using the quick sort algorithm.

APPARATUS:

Laptop with C++ compiler (MinGW), Text Editor / IDE (VS Code), Terminal/Console (Command Prompt).

THEORY:

Quick sort is a divide-and-conquer algorithm that selects a pivot element, partitions the array around the pivot, and recursively sorts the subarrays. It has an average and best-case time complexity of O(n log n) and worst-case O(n²).

ALGORITHM:

Start the program and include necessary header files.

Input the number of elements and the array elements.

Select a pivot element and partition the array into two subarrays: elements less than pivot and elements greater than pivot.

Recursively apply quick sort on the subarrays.

Combine the subarrays and pivot to form the sorted array.

Display the sorted array.

Stop the program.

CONCLUSION:

The program successfully sorts an array using quick sort.
